<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fx-team</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fx-team.github.io/"/>
  <updated>2018-01-08T07:25:51.580Z</updated>
  <id>https://fx-team.github.io/</id>
  
  <author>
    <name>一个富有想象力的前端团队fx-team</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>phaser问题开发游戏总结 - 2018/01/08</title>
    <link href="https://fx-team.github.io/2018/01/08/phaser%E5%BC%80%E5%8F%91%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%20-%202018.01.08/"/>
    <id>https://fx-team.github.io/2018/01/08/phaser开发游戏问题总结 - 2018.01.08/</id>
    <published>2018-01-08T10:13:33.000Z</published>
    <updated>2018-01-08T07:25:51.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>phaser是一个非常好用的html5游戏开发框架，官网上是这样介绍的：“一个快速、免费并且完全开源的框架，提供Canvas和WebGL两种渲染方式，致力于增强桌面端与移动端浏览器游戏的体验”。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="开始游戏的场景"><a href="#开始游戏的场景" class="headerlink" title="开始游戏的场景"></a>开始游戏的场景</h3><p>html5标准新加了一个 canvas标签，在canvas上我们可以通过js绘制各种各样的内容，游戏内包含着场景，精灵等要素。我们绘制了宽度600高度250，的一个canvas画布。游戏渲染模式使用Phaser.AUTO，也就是自动检测，在浏览器支持WebGL的时候使用WebGL渲染，不支持的时候回退到Canvas渲染。。并且加载了Splash场景，通过start，进入了Splash场景。等Splash场景结束后，我们可以通过<code>game.state.start(&#39;Main&#39;);</code>来加载Main场景实现场景之前的切换。在场景中有各种各样的方法来控制场景的展示，init方法，preload方法，create方法和update方法，分别管理当前场景的初始化、预加载、生成游戏对象以及更新游戏循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> game = <span class="keyword">new</span> Phaser.Game(<span class="number">600</span>, <span class="number">250</span> , Phaser.AUTO,<span class="string">""</span>);</span><br><span class="line"><span class="keyword">var</span> main = <span class="keyword">new</span> Phaser.State();</span><br><span class="line">game.state.add(<span class="string">'Splash'</span>, Splash);</span><br><span class="line">game.state.add(<span class="string">'Main'</span>, Main);</span><br><span class="line">game.state.start(<span class="string">'Splash'</span>);</span><br></pre></td></tr></table></figure><p>通过这些方法，就可以完成一个非常炫酷的phaser游戏了</p><h3 id="丰富我们的游戏"><a href="#丰富我们的游戏" class="headerlink" title="丰富我们的游戏"></a>丰富我们的游戏</h3><p>初始化Init方法：启动物理引擎（ARCADE），这是Phaser框架自带的最简单的物理引擎，用于矩形盒的碰撞检测。。<br>main.init = function(){<br>    game.physics.startSystem(Phaser.Physics.ARCADE);<br>    game.world.enableBody = true;<br>}<br>预加载方法：加载各类游戏资源，并设置唯一id，被精灵引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">game.load.image(<span class="string">'floor'</span>, <span class="string">'img/floor.png'</span>);</span><br></pre></td></tr></table></figure><p>生成游戏对象方法：生成游戏地图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main.create = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.floors = game.add.group();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//floor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> floor = game.add.sprite(<span class="number">30</span>*i, <span class="number">90</span>, <span class="string">'box'</span>,<span class="string">''</span>, <span class="keyword">this</span>.floors);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更新循环方法：通过方向键控制主角左右移动和跳跃，当主角撞到地板，做销毁处理，并且重新开始游戏。这样我们就完成一个简单的跳跃障碍物游戏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    game.physics.arcade.overlap(<span class="keyword">this</span>.player, <span class="keyword">this</span>.floor, <span class="keyword">this</span>.kill, <span class="literal">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cursor.left.isDown) </span><br><span class="line">        <span class="keyword">this</span>.player.body.velocity.x = <span class="number">-200</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cursor.up.isDown &amp;&amp; <span class="keyword">this</span>.player.body.touching.down) </span><br><span class="line">        <span class="keyword">this</span>.player.body.velocity.y = <span class="number">-250</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="phaser开发游戏问题总结"><a href="#phaser开发游戏问题总结" class="headerlink" title="phaser开发游戏问题总结"></a>phaser开发游戏问题总结</h2><h3 id="iphone下游戏显示模糊"><a href="#iphone下游戏显示模糊" class="headerlink" title="iphone下游戏显示模糊"></a>iphone下游戏显示模糊</h3><p>这是因为iphone现在都是retina屏幕，在retina屏幕下，会用2个像素点的宽度去渲染图片的1个像素点，因此该图片在retina屏幕上实际会占据200x200像素的空间，相当于图片被放大了一倍，因此图片会变得模糊。所以我们在初始化canvas大小不应该是屏幕的 大小去渲染，使用屏幕大小俩倍做渲染，同时通过css来讲canvas缩小，就可以解决问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(<span class="string">'100'</span>, <span class="string">'100'</span>, Phaser.CANVAS, <span class="string">'content'</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">super</span>(<span class="string">'200'</span>, <span class="string">'200'</span>, Phaser.CANVAS, <span class="string">'content'</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><p>phaser社区版本提供了 grunt打包工具，可以自行缩减比如常用 wap端游戏不需要的按键控制，多余的物理引擎，来缩小资源大小。<br>整个资源打包也可以通过webpack内置的压缩进行优化。<br>游戏的图片其实对于整个资源占比很大，对一些按钮，icon，标志图片等较小图片可以进行合图操作，减少大量的http请求，对一些超过1024*1024大小的图片进行些许压缩。</p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ul><li>减少不必要的计算<ul><li>图片阴影，发光效果，添加mask效果，可以直接用图片替代</li><li>复杂文字效果使用图片</li></ul></li><li>在主循环update逻辑坐到<code>精简</code></li><li>游戏内不直接使用setTimeout setInterVal</li><li>精灵数量的控制和注意及时的销毁，保证内存不泄露</li></ul><h2 id="phaser-学习资源"><a href="#phaser-学习资源" class="headerlink" title="phaser 学习资源"></a>phaser 学习资源</h2><p><a href="https://github.com/orange-games" target="_blank" rel="noopener">phaser 插件合集</a><br><a href="http://www.phaser.io" target="_blank" rel="noopener">phaser官网</a><br><a href="http://phaserengine.com" target="_blank" rel="noopener">phaser中文官网</a><br><a href="https://github.com/channingbreeze/games" target="_blank" rel="noopener">phaser 小游戏合集</a><br><a href="https://github.com/lean/phaser-es6-webpack" target="_blank" rel="noopener">phaser webpack配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;phaser是一个非常好用的html5游戏开发框架，官网上是这样介绍的：“一个快速、免费并且完全开源的框架，提供Canvas和WebGL两种
      
    
    </summary>
    
    
      <category term="游戏" scheme="https://fx-team.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://fx-team.github.io/2018/01/08/test/"/>
    <id>https://fx-team.github.io/2018/01/08/test/</id>
    <published>2018-01-08T06:54:54.000Z</published>
    <updated>2018-01-08T11:02:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>test1sdfkkk sdf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;test1sdfkkk sdf&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端技术周刊 - 2018/01/05</title>
    <link href="https://fx-team.github.io/2018/01/05/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%20-%202018.01.05/"/>
    <id>https://fx-team.github.io/2018/01/05/前端技术周刊 - 2018.01.05/</id>
    <published>2018-01-05T10:13:33.000Z</published>
    <updated>2018-01-08T07:25:51.581Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://36kr.com/p/5110763.html" target="_blank" rel="noopener">2018 年最值得关注的 JavaScript 趋势</a><br><em>JavaScript渗透的范围越来越广，它能做的事情已经远不止前端开发而已。不久前stateofjs.com刚刚发布了2017 JavaScript现状报告，现在Ryan Chartrand非常应景地推出了2018年的JavaScript发展趋势，把这两份文章一起结合来看，相信作为JS开发者的你一定不再迷茫。</em></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651000212&amp;idx=1&amp;sn=753c242f4132347737fa854a514cfe35" target="_blank" rel="noopener">2017技术圈年度大事件盘点</a></p><p><em>年终总结的意义在于，总结过去，展望未来。在这即将过去的 2017 年，回顾技术圈年度大事件。</em></p><p><a href="https://zhuanlan.zhihu.com/p/32372885" target="_blank" rel="noopener">解读 2017 年终全球 JavaScript 技术调查结果</a></p><p><em>结合 stateofjs 公布的 2017 年关于 JavaScript 全球调查结果来解读下即将要过去的这一年的 JavaScript 技术相关情况。</em></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485600&amp;idx=1&amp;sn=12e229c90cc08e8f14dcc1ae7f27abd6" target="_blank" rel="noopener">PWA是否能带来新一轮大前端技术洗牌</a></p><p><em>对于 Native App 来说，其 最大的痛点是由于其天生封闭的基因，内容无法被索引，这会导致后续一系列的问题。而随着移动互联网的发展，用户下载 App 的热情也逐渐减弱，再加上用户 80% 的时间被 Top3 的超级 App 占据，对于站点来说，应用分发成本也因此越来越高了。相对于 Native App 的封闭，PWA 却是完全开放的——PWA 现有的所有技术都是遵循 W3C 的标准，完全开放，因此能够快速被站点接受、被浏览器快速支持。值得一提的是，为了解开传统 Web 的两个枷锁，除 PWA 之外，业界也诞生了很多技术方案，例如部分厂商推出的小程序技术。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://36kr.com/p/5110763.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018 年最值得关注的 JavaScript 趋势&lt;/a&gt;&lt;br&gt;&lt;em&gt;JavaScript渗透的范围越来越广，它能做的事情已
      
    
    </summary>
    
    
      <category term="技术周刊" scheme="https://fx-team.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://fx-team.github.io/2018/01/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://fx-team.github.io/2018/01/04/新的开始/</id>
    <published>2018-01-04T06:30:53.000Z</published>
    <updated>2018-01-08T07:25:51.582Z</updated>
    
    <content type="html"><![CDATA[<p>这是<strong>fx-team</strong>团队2018年的第一篇博客，新的一年朝着自己的目标前进。本博客用于记录<strong>fx-team</strong>日常学习、工作反思、开源作品等各个方面。</p><p>2018年乘风破浪，我们的征途是星辰大海。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是&lt;strong&gt;fx-team&lt;/strong&gt;团队2018年的第一篇博客，新的一年朝着自己的目标前进。本博客用于记录&lt;strong&gt;fx-team&lt;/strong&gt;日常学习、工作反思、开源作品等各个方面。&lt;/p&gt;
&lt;p&gt;2018年乘风破浪，我们的征途是星辰大海。&lt;/p
      
    
    </summary>
    
    
      <category term="点滴" scheme="https://fx-team.github.io/tags/%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
</feed>
